{"version":3,"sources":["register.js"],"names":[],"mappings":"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","file":"register-compiled.js","sourcesContent":["/**\n * Created by LamDo on 1/3/16.\n */\nfunction register(appName) {\n\n    var app = angular.module(appName);\n\n    return {\n        directive: directive,\n        controller: controller,\n        service: service,\n        provider: provider,\n        factory: factory\n    };\n\n    function directive(name, constructorFn) {\n\n        constructorFn = _normalizeConstructor(constructorFn);\n\n        if (!constructorFn.prototype.compile) {\n            // create an empty compile function if none was defined.\n            constructorFn.prototype.compile = () => {};\n        }\n\n        var originalCompileFn = _cloneFunction(constructorFn.prototype.compile);\n\n        // Decorate the compile method to automatically return the link method (if it exists)\n        // and bind it to the context of the constructor (so `this` works correctly).\n        // This gets around the problem of a non-lexical \"this\" which occurs when the directive class itself\n        // returns `this.link` from within the compile function.\n        _override(constructorFn.prototype, 'compile', function () {\n            return function () {\n                originalCompileFn.apply(this, arguments);\n\n                if (constructorFn.prototype.link) {\n                    return constructorFn.prototype.link.bind(this);\n                }\n            };\n        });\n\n        var factoryArray = _createFactoryArray(constructorFn);\n\n        app.directive(name, factoryArray);\n        return this;\n    }\n\n    function controller(name, contructorFn) {\n        app.controller(name, contructorFn);\n        return this;\n    }\n\n    function service(name, contructorFn) {\n        app.service(name, contructorFn);\n        return this;\n    }\n\n    function provider(name, constructorFn) {\n        app.provider(name, constructorFn);\n        return this;\n    }\n\n    function factory(name, constructorFn) {\n        constructorFn = _normalizeConstructor(constructorFn);\n        var factoryArray = _createFactoryArray(constructorFn);\n        app.factory(name, factoryArray);\n        return this;\n    }\n\n    /**\n     * If the constructorFn is an array of type ['dep1', 'dep2', ..., constructor() {}]\n     * we need to pull out the array of dependencies and add it as an $inject property of the\n     * actual constructor function.\n     * @param input\n     * @returns {*}\n     * @private\n     */\n    function _normalizeConstructor(input) {\n        var constructorFn;\n\n        if (input.constructor === Array) {\n            //\n            var injected = input.slice(0, input.length - 1);\n            constructorFn = input[input.length - 1];\n            constructorFn.$inject = injected;\n        } else {\n            constructorFn = input;\n        }\n\n        return constructorFn;\n    }\n\n    /**\n     * Convert a constructor function into a factory function which returns a new instance of that\n     * constructor, with the correct dependencies automatically injected as arguments.\n     *\n     * In order to inject the dependencies, they must be attached to the constructor function with the\n     * `$inject` property annotation.\n     *\n     * @param constructorFn\n     * @returns {Array.<T>}\n     * @private\n     */\n    function _createFactoryArray(constructorFn) {\n        // get the array of dependencies that are needed by this component (as contained in the `$inject` array)\n        var args = constructorFn.$inject || [];\n        var factoryArray = args.slice(); // create a copy of the array\n        // The factoryArray uses Angular's array notation whereby each element of the array is the name of a\n        // dependency, and the final item is the factory function itself.\n        factoryArray.push((...args) => {\n            //return new constructorFn(...args);\n            var instance = new constructorFn(...args);\n            for (var key in instance) {\n                instance[key] = instance[key];\n            }\n            return instance;\n        });\n\n        return factoryArray;\n    }\n\n    /**\n     * Clone a function\n     * @param original\n     * @returns {Function}\n     */\n    function _cloneFunction(original) {\n        return function() {\n            return original.apply(this, arguments);\n        };\n    }\n\n    /**\n     * Override an object's method with a new one specified by `callback`.\n     * @param object\n     * @param methodName\n     * @param callback\n     */\n    function _override(object, methodName, callback) {\n        object[methodName] = callback(object[methodName])\n    }\n\n}\n"]}